---
title: "面试"
categories:
  - 面试
tags:
  - 面试
toc: true
toc_label: "目录"
toc_icon: "cog"    
---

网上收集的面试集合
# php
## php 命名空间是如何定义的？
命名空间通过关键字namespace 来声明。如果一个文件中包含命名空间，它必须在其它所有代码之前声明命名空间，除了一个以外：declare关键字。\
命名空间一个最明确的目的就是解决重名问题，PHP中不允许两个函数或者类出现相同的名字，否则会产生一个致命的错误。这种情况下只要避免命名重复就可以解决，最常见的一种做法是约定一个前缀。\
基础\
命名空间将代码划分出不同的空间（区域），每个空间的常量、函数、类（为了偷懒，我下边都将它们称为元素）的名字互不影响， 这个有点类似我们常常提到的‘封装'的概念

## php 接口是如何实现的？
如果一个抽象类里面的所有方法都是抽象方法，且没有声明变量，而且接口里面所有的成员都是public权限的，那么这种特殊的抽象类就叫接口\
接口是什么？\
        使用接口（interface），可以指定某个类必须实现哪些方法，但不需要定义这些方法的具体内容。\
        接口是通过 interface 关键字来定义的，就像定义一个标准的类一样，但其中定义所有的方法都是空的。\
        接口中定义的所有方法都必须是公有，这是接口的特性。\
接口使用规范\
        接口不能实例化\
        接口的属性必须是常量\
        接口的方法必须是public【默认public】，且不能有函数体\
        类必须实现接口的所有方法\
        一个类可以同时实现多个接口，用逗号隔开\
        接口可以继承接口【用的少】

## 如何接收微信发送的内容？
    $postStr = file_get_contents("php://input");      

## php 是单线程还是多线程
单线程

## 什么是控制反转
控制反转是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection, DI）, 还有一种叫"依赖查找"（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体，将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。

## 什么是依赖注入，解决了那些问题
1. 什么是依赖注入
    - 依赖注入是控制反转的一种实现，实现代码解耦，便于单元测试。因为它并不需要了解自身所依赖的类，而只需要知道所依赖的类实现了自身所需要的方法就可以了。
2. 解决那些问题
    - 依赖之间的解耦
    - 单元测试，方便Mock


# mysql
## mysql 优化的一般步骤
1. sql及索引
    - 索引优化
    - 开启慢查询日志
    - 分析sql语句
    - 分析是否用上了索引
2. 数据库表结构
3. 服务器配置    

## 对事务的理解
### 描述
是多个步骤为一个过程的事务（整体）
1. 事务使用innodb 数据库引擎
    - 如果你不是innodb，开启事务,删除那就真的删除了.
2. 要么成批的sql全部执行，要么都不执行
3. 事务用来管理 insert update delete语句

### 事务条件（ACID）
1. 原子性
    - 一组事务要么成功，要么撤回
2. 稳定性
    - 有非法数据(外键约束),事务撤回
3. 隔离性
    - 事务独立运行。一个事务处理后的结果，影响了其他事务，那么其他事务会撤回。事务的100%隔离，需要牺牲速度。
4. 可靠性
    - 软件或者硬件崩溃，Innodb 表驱动，会利用日志文件，重构修改。

### 关键字
Commit 提交 当一个事务完成后，发出commit 命令使所有的参与表 完成更改。\
Rollback 回滚 如果发送故障，发出rollback命令 使事务返回到 所有表以前的状态。

### 语句
```
set autocommit = 0;
sql操作
savepoint p1;
sql操作
savepoint p2;
sql操作
ROLLBACK to p2;
commit;
```

## 什么是组合索引，以及使用情况？
### 描述
将多个字段共同添加到一个索引
### 使用规则 最佳左匹配规则
当前组合索引是这样一个顺序 ind_status_email(status,email)\
单独查询status时，可以用到这个索引，单独查询email时，却用不到

#### 总结
查询字段有组合索引之外的字段时，查询条件必须包含组合索引中的第一个字段，才会用到该索引
查询字段只限于组合索引内的字段时，查询条件只要有组合索引中的字段，就会用到该索引
### id name  password  建立组合索引 怎么建立?为什么?
    alter table users add index user_password_index(name, password)
因为最左原则，一般name查询比较多所以name放在前面，很少会通过password来查，根据字段的辨识度来做

## 为什么 like 在 % 第一个字符用不到索引？
假设查询姓名 like %名 会先查询当前所有的姓，然后再去查有没有符合名的数据，所以这样会进行全表扫描，从而用不到索引

## 为什么不分开加索引？而非要加组合索引
1. 索引不是越多越好，索引会占用资源，影响插入性能
2. 要根据要加的索引字段的辨识度来创建，如果你给辨识度小的字段加索引将会出现加了你不常用、影响性能等问题
3. 尤其是 name pasword 经典的组合索引例子

## bin.log 日志是什么？
1. 记录数据库变化操作的二进制日志文件
2. 记录了所有的数据库变化操作(数据增删改，创建表等)
3. 在数据丢失的紧急情况下，我们往往会想到用binlog日志功能进行数据恢复

## MyISAM 和 InnoDB 的区别？从事物和表结构分析？
1. MyISAM不支持事务，InnoDB是事务类型的存储引擎，当我们的表需要用到事务支持的时候，那肯定是不能选择MyISAM了
2. MyISAM只支持表级锁，，而InnoDB支持行级锁和表级锁默认为行级锁
3. MyISAM引擎不支持外键，InnoDB支持外键
4. MyISAM支持全文类型索引，而InnoDB不支持全文索引
5. MyISAM引擎的表在大量高并发的读写下会经常出现表损坏的情况
6. MyISAM保有表的总行数，InnoDB只能遍历


# redis
## 什么是redis
* 开源先进的key-value存储
    - 远程字典服务器，内存级数据库，数据结构服务器
    - 一个基于内存的网络存储系统
    
## redis 数据类型有哪些
1. 字符串
2. 列表
3. 哈希
4. 集合
5. 有序集合

## redis 的持久化
###RDB
####持久化方式
根据定时配置将内存数据存储在磁盘上

###AOF
####持久化方式
每次执行命令时将命令记录下来

## redis 适用场景
1. 取最新 N 个数据的操作
2. 排行榜应用,取 TOP N 操作 
3. 需要精准设定过期时间的应用
4. 计数器应用
5. Uniq 操作,获取某段时间所有数据排重值
6. 实时系统,反垃圾系统
7. Pub/Sub 构建实时消息系统
8. 构建队列系统
9. 缓存数据

## redis 特点
1. Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。
2. Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。
3. Redis支持数据的备份，即master-slave模式的数据备份。

## redis 异常有哪些
### 缓存穿透
#### 描述
大量请求redis和db中不存在的key
#### 解决方案
1. 设置不存在的空key设置为null
2. 使用布隆过滤器来过滤空key
3. 一般对于这种访问可能由于遭到攻击引起，可以对请求进行身份鉴权、数据合法行校验等。

### 缓存雪崩
#### 描述
缓存服务器宕机或大量key同时过期，导致所有请求都直接请求到数据库上导致数据库压力增大
#### 解决方案
1. 将key的过期时间打乱，避免大量key同时过期
2. 对缓存服务器做高可用处理
3. 使用互斥锁或者队列

### 缓存击穿
#### 描述
redis中一个热点key过期（大量用户访问该热点key，但是热点key过期）
#### 解决方案
1. 热点数据不过期，更新数据就好了
2. 可以在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，后面的线程进来发现已经有缓存了，就直接走缓存，从而保护数据库。但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。

## memcached与redis的区别
### 两者对比
redis提供数据持久化功能，memcached无持久化；\
redis的数据结构比memcached要丰富，能完成场景以外的事情；\
memcached的单个key限制在250B，value限制在1MB；redis的K、V都为512MB;当然这些值可以在源码中修改；\
memcached数据回收基于LRU算法，Redis提供了多种回收策略（包含LRU），但是redis的回收策的过期逻辑不可依赖，没法根据是否存在一个key判断是否过期。但是可根据ttl返回值判断是否过期；\
memcached使用多线程，而redis使用单线程，基于IO多路复用实现高速访问。所以可以理解为在极端情况下memcached的吞吐大于redis。

### 结论
普通KV场景：memcached、redis都可以。\
从功能模块单一这个角度考虑的话，推荐memcached，只做cache一件事。\
在KV长度偏大、数据结构复杂（比如取某个value的一段数据）、需要持久化的情况下，用redis更适合：但是在使用redis的时候单个请求的阻塞会导致后续请求的积压，需要注意

